#! /nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/bin/vvp
:ivl_version "12.0 (stable)";
:ivl_delay_selection "TYPICAL";
:vpi_time_precision + 0;
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/system.vpi";
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/vhdl_sys.vpi";
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/vhdl_textio.vpi";
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/v2005_math.vpi";
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/va_math.vpi";
:vpi_module "/nix/store/3yb27x678adgxjpa367g0cn2dn2myqrc-iverilog-12.0/lib/ivl/v2009.vpi";
S_0x1fb76660 .scope package, "$unit" "$unit" 2 1;
 .timescale 0 0;
S_0x1fb78550 .scope module, "buff_gate" "buff_gate" 3 78;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "buff_a";
    .port_info 1 /OUTPUT 1 "buff_out";
o0x7f7d1139e018 .functor BUFZ 1, C4<z>; HiZ drive
L_0x1fbafdd0 .functor BUFZ 1, o0x7f7d1139e018, C4<0>, C4<0>, C4<0>;
v0x1fb7c790_0 .net "buff_a", 0 0, o0x7f7d1139e018;  0 drivers
v0x1fbaa7e0_0 .net "buff_out", 0 0, L_0x1fbafdd0;  1 drivers
S_0x1fb7beb0 .scope module, "d_ff" "d_ff" 4 1;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "clk";
    .port_info 1 /INPUT 1 "rst";
    .port_info 2 /INPUT 1 "data_in";
    .port_info 3 /OUTPUT 1 "data_out";
P_0x1fb8a5f0 .param/l "WIDTH" 0 4 1, +C4<00000000000000000000000000000001>;
o0x7f7d1139e0d8 .functor BUFZ 1, C4<z>; HiZ drive
v0x1fbaa920_0 .net "clk", 0 0, o0x7f7d1139e0d8;  0 drivers
o0x7f7d1139e108 .functor BUFZ 1, C4<z>; HiZ drive
v0x1fbaaa00_0 .net "data_in", 0 0, o0x7f7d1139e108;  0 drivers
v0x1fbaaae0_0 .var "data_out", 0 0;
o0x7f7d1139e168 .functor BUFZ 1, C4<z>; HiZ drive
v0x1fbaaba0_0 .net "rst", 0 0, o0x7f7d1139e168;  0 drivers
E_0x1fb42530 .event posedge, v0x1fbaa920_0;
S_0x1fb6f040 .scope module, "nand_gate" "nand_gate" 3 34;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "nand_a";
    .port_info 1 /INPUT 1 "nand_b";
    .port_info 2 /OUTPUT 1 "nand_out";
o0x7f7d1139e288 .functor BUFZ 1, C4<z>; HiZ drive
o0x7f7d1139e2b8 .functor BUFZ 1, C4<z>; HiZ drive
L_0x1fbafe40 .functor AND 1, o0x7f7d1139e288, o0x7f7d1139e2b8, C4<1>, C4<1>;
v0x1fbaace0_0 .net *"_ivl_1", 0 0, L_0x1fbafe40;  1 drivers
v0x1fbaadc0_0 .net "nand_a", 0 0, o0x7f7d1139e288;  0 drivers
v0x1fbaae80_0 .net "nand_b", 0 0, o0x7f7d1139e2b8;  0 drivers
v0x1fbaaf20_0 .net "nand_out", 0 0, L_0x1fbafeb0;  1 drivers
L_0x1fbafeb0 .reduce/nor L_0x1fbafe40;
S_0x1fb80f60 .scope module, "nor_gate" "nor_gate" 3 45;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "nor_a";
    .port_info 1 /INPUT 1 "nor_b";
    .port_info 2 /OUTPUT 1 "nor_out";
o0x7f7d1139e3d8 .functor BUFZ 1, C4<z>; HiZ drive
o0x7f7d1139e408 .functor BUFZ 1, C4<z>; HiZ drive
L_0x1fbaffd0 .functor OR 1, o0x7f7d1139e3d8, o0x7f7d1139e408, C4<0>, C4<0>;
v0x1fbab060_0 .net *"_ivl_1", 0 0, L_0x1fbaffd0;  1 drivers
v0x1fbab120_0 .net "nor_a", 0 0, o0x7f7d1139e3d8;  0 drivers
v0x1fbab1e0_0 .net "nor_b", 0 0, o0x7f7d1139e408;  0 drivers
v0x1fbab280_0 .net "nor_out", 0 0, L_0x1fbb00a0;  1 drivers
L_0x1fbb00a0 .reduce/nor L_0x1fbaffd0;
S_0x1fb81140 .scope module, "not_gate" "not_gate" 3 24;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "not_a";
    .port_info 1 /OUTPUT 1 "not_out";
o0x7f7d1139e4f8 .functor BUFZ 1, C4<z>; HiZ drive
v0x1fbab3c0_0 .net "not_a", 0 0, o0x7f7d1139e4f8;  0 drivers
v0x1fbab480_0 .net "not_out", 0 0, L_0x1fbb01c0;  1 drivers
L_0x1fbb01c0 .reduce/nor o0x7f7d1139e4f8;
S_0x1fb81b80 .scope module, "testbench" "testbench" 5 1;
 .timescale 0 0;
v0x1fbaf220_0 .var "adder_carry", 0 0;
v0x1fbaf2e0_0 .var "gate_a", 0 0;
v0x1fbaf3a0_0 .var "gate_b", 0 0;
v0x1fbaf440_0 .net "test_full_adder_carryout", 0 0, L_0x1fbb0d70;  1 drivers
v0x1fbaf4e0_0 .net "test_full_adder_sum", 0 0, L_0x1fbb0b00;  1 drivers
v0x1fbaf620_0 .net "test_half_adder_carry", 0 0, L_0x1fbb0290;  1 drivers
v0x1fbaf710_0 .net "test_half_adder_sum", 0 0, L_0x1fbb0560;  1 drivers
S_0x1fbab5a0 .scope module, "u_full_adder" "full_adder" 5 17, 6 1 0, S_0x1fb81b80;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "full_adder_a";
    .port_info 1 /INPUT 1 "full_adder_b";
    .port_info 2 /INPUT 1 "full_adder_carry_in";
    .port_info 3 /OUTPUT 1 "full_adder_sum";
    .port_info 4 /OUTPUT 1 "full_adder_carry_out";
P_0x1fbab780 .param/l "WIDTH" 0 6 1, +C4<00000000000000000000000000000001>;
v0x1fbad750_0 .net "and1", 0 0, L_0x1fbb0c10;  1 drivers
v0x1fbad840_0 .net "and2", 0 0, L_0x1fbb0cc0;  1 drivers
v0x1fbad950_0 .net "full_adder_a", 0 0, v0x1fbaf2e0_0;  1 drivers
v0x1fbada40_0 .net "full_adder_b", 0 0, v0x1fbaf3a0_0;  1 drivers
v0x1fbadb30_0 .net "full_adder_carry_in", 0 0, v0x1fbaf220_0;  1 drivers
v0x1fbadc90_0 .net "full_adder_carry_out", 0 0, L_0x1fbb0d70;  alias, 1 drivers
v0x1fbadd50_0 .net "full_adder_sum", 0 0, L_0x1fbb0b00;  alias, 1 drivers
v0x1fbaddf0_0 .net "xor1", 0 0, L_0x1fbb0880;  1 drivers
S_0x1fbab8b0 .scope module, "and_a_b" "and_gate" 6 31, 3 2 0, S_0x1fbab5a0;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "and_a";
    .port_info 1 /INPUT 1 "and_b";
    .port_info 2 /OUTPUT 1 "and_out";
L_0x1fbb0cc0 .functor AND 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<1>, C4<1>;
v0x1fbabb20_0 .net "and_a", 0 0, v0x1fbaf2e0_0;  alias, 1 drivers
v0x1fbabc00_0 .net "and_b", 0 0, v0x1fbaf3a0_0;  alias, 1 drivers
v0x1fbabcc0_0 .net "and_out", 0 0, L_0x1fbb0cc0;  alias, 1 drivers
S_0x1fbabe10 .scope module, "and_carryin_xor1" "and_gate" 6 24, 3 2 0, S_0x1fbab5a0;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "and_a";
    .port_info 1 /INPUT 1 "and_b";
    .port_info 2 /OUTPUT 1 "and_out";
L_0x1fbb0c10 .functor AND 1, v0x1fbaf220_0, L_0x1fbb0880, C4<1>, C4<1>;
v0x1fbac040_0 .net "and_a", 0 0, v0x1fbaf220_0;  alias, 1 drivers
v0x1fbac120_0 .net "and_b", 0 0, L_0x1fbb0880;  alias, 1 drivers
v0x1fbac1e0_0 .net "and_out", 0 0, L_0x1fbb0c10;  alias, 1 drivers
S_0x1fbac330 .scope module, "or_and1_and2" "or_gate" 6 37, 3 13 0, S_0x1fbab5a0;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "or_a";
    .port_info 1 /INPUT 1 "or_b";
    .port_info 2 /OUTPUT 1 "or_out";
L_0x1fbb0d70 .functor OR 1, L_0x1fbb0c10, L_0x1fbb0cc0, C4<0>, C4<0>;
v0x1fbac590_0 .net "or_a", 0 0, L_0x1fbb0c10;  alias, 1 drivers
v0x1fbac660_0 .net "or_b", 0 0, L_0x1fbb0cc0;  alias, 1 drivers
v0x1fbac730_0 .net "or_out", 0 0, L_0x1fbb0d70;  alias, 1 drivers
S_0x1fbac840 .scope module, "xor_a_b" "xor_gate" 6 11, 3 56 0, S_0x1fbab5a0;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "xor_a";
    .port_info 1 /INPUT 1 "xor_b";
    .port_info 2 /OUTPUT 1 "xor_out";
L_0x1fbb0670 .functor OR 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<0>, C4<0>;
L_0x1fbb0700 .functor AND 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<1>, C4<1>;
L_0x1fbb0880 .functor AND 1, L_0x1fbb0670, L_0x1fbb0790, C4<1>, C4<1>;
v0x1fbaca70_0 .net *"_ivl_1", 0 0, L_0x1fbb0670;  1 drivers
v0x1fbacb50_0 .net *"_ivl_3", 0 0, L_0x1fbb0700;  1 drivers
v0x1fbacc10_0 .net *"_ivl_5", 0 0, L_0x1fbb0790;  1 drivers
v0x1fbacce0_0 .net "xor_a", 0 0, v0x1fbaf2e0_0;  alias, 1 drivers
v0x1fbacdb0_0 .net "xor_b", 0 0, v0x1fbaf3a0_0;  alias, 1 drivers
v0x1fbacea0_0 .net "xor_out", 0 0, L_0x1fbb0880;  alias, 1 drivers
L_0x1fbb0790 .reduce/nor L_0x1fbb0700;
S_0x1fbacf90 .scope module, "xor_xor1_carryin" "xor_gate" 6 17, 3 56 0, S_0x1fbab5a0;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "xor_a";
    .port_info 1 /INPUT 1 "xor_b";
    .port_info 2 /OUTPUT 1 "xor_out";
L_0x1fbb0940 .functor OR 1, L_0x1fbb0880, v0x1fbaf220_0, C4<0>, C4<0>;
L_0x1fbb09d0 .functor AND 1, L_0x1fbb0880, v0x1fbaf220_0, C4<1>, C4<1>;
L_0x1fbb0b00 .functor AND 1, L_0x1fbb0940, L_0x1fbb0a60, C4<1>, C4<1>;
v0x1fbad210_0 .net *"_ivl_1", 0 0, L_0x1fbb0940;  1 drivers
v0x1fbad2f0_0 .net *"_ivl_3", 0 0, L_0x1fbb09d0;  1 drivers
v0x1fbad3b0_0 .net *"_ivl_5", 0 0, L_0x1fbb0a60;  1 drivers
v0x1fbad450_0 .net "xor_a", 0 0, L_0x1fbb0880;  alias, 1 drivers
v0x1fbad540_0 .net "xor_b", 0 0, v0x1fbaf220_0;  alias, 1 drivers
v0x1fbad630_0 .net "xor_out", 0 0, L_0x1fbb0b00;  alias, 1 drivers
L_0x1fbb0a60 .reduce/nor L_0x1fbb09d0;
S_0x1fbadf10 .scope module, "u_half_adder" "half_adder" 5 7, 7 1 0, S_0x1fb81b80;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "half_adder_a";
    .port_info 1 /INPUT 1 "half_adder_b";
    .port_info 2 /OUTPUT 1 "half_adder_sum";
    .port_info 3 /OUTPUT 1 "half_adder_carry";
P_0x1fbae110 .param/l "WIDTH" 0 7 1, +C4<00000000000000000000000000000001>;
v0x1fbaee70_0 .net "half_adder_a", 0 0, v0x1fbaf2e0_0;  alias, 1 drivers
v0x1fbaef30_0 .net "half_adder_b", 0 0, v0x1fbaf3a0_0;  alias, 1 drivers
v0x1fbaeff0_0 .net "half_adder_carry", 0 0, L_0x1fbb0290;  alias, 1 drivers
v0x1fbaf0c0_0 .net "half_adder_sum", 0 0, L_0x1fbb0560;  alias, 1 drivers
S_0x1fbae220 .scope module, "and1" "and_gate" 7 9, 3 2 0, S_0x1fbadf10;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "and_a";
    .port_info 1 /INPUT 1 "and_b";
    .port_info 2 /OUTPUT 1 "and_out";
L_0x1fbb0290 .functor AND 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<1>, C4<1>;
v0x1fbae470_0 .net "and_a", 0 0, v0x1fbaf2e0_0;  alias, 1 drivers
v0x1fbae530_0 .net "and_b", 0 0, v0x1fbaf3a0_0;  alias, 1 drivers
v0x1fbae5f0_0 .net "and_out", 0 0, L_0x1fbb0290;  alias, 1 drivers
S_0x1fbae6f0 .scope module, "xor1" "xor_gate" 7 15, 3 56 0, S_0x1fbadf10;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "xor_a";
    .port_info 1 /INPUT 1 "xor_b";
    .port_info 2 /OUTPUT 1 "xor_out";
L_0x1fbb0300 .functor OR 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<0>, C4<0>;
L_0x1fbb03a0 .functor AND 1, v0x1fbaf2e0_0, v0x1fbaf3a0_0, C4<1>, C4<1>;
L_0x1fbb0560 .functor AND 1, L_0x1fbb0300, L_0x1fbb0440, C4<1>, C4<1>;
v0x1fbae920_0 .net *"_ivl_1", 0 0, L_0x1fbb0300;  1 drivers
v0x1fbaea00_0 .net *"_ivl_3", 0 0, L_0x1fbb03a0;  1 drivers
v0x1fbaeac0_0 .net *"_ivl_5", 0 0, L_0x1fbb0440;  1 drivers
v0x1fbaeb60_0 .net "xor_a", 0 0, v0x1fbaf2e0_0;  alias, 1 drivers
v0x1fbaec00_0 .net "xor_b", 0 0, v0x1fbaf3a0_0;  alias, 1 drivers
v0x1fbaed30_0 .net "xor_out", 0 0, L_0x1fbb0560;  alias, 1 drivers
L_0x1fbb0440 .reduce/nor L_0x1fbb03a0;
S_0x1fb81d10 .scope module, "xnor_gate" "xnor_gate" 3 67;
 .timescale 0 0;
    .port_info 0 /INPUT 1 "xnor_a";
    .port_info 1 /INPUT 1 "xnor_b";
    .port_info 2 /OUTPUT 1 "xnor_out";
o0x7f7d1139efa8 .functor BUFZ 1, C4<z>; HiZ drive
o0x7f7d1139efd8 .functor BUFZ 1, C4<z>; HiZ drive
L_0x1fbb0f40 .functor OR 1, o0x7f7d1139efa8, o0x7f7d1139efd8, C4<0>, C4<0>;
L_0x1fbb0fd0 .functor AND 1, o0x7f7d1139efa8, o0x7f7d1139efd8, C4<1>, C4<1>;
L_0x1fbb1160 .functor AND 1, L_0x1fbb0f40, L_0x1fbb1070, C4<1>, C4<1>;
v0x1fbaf800_0 .net *"_ivl_1", 0 0, L_0x1fbb0f40;  1 drivers
v0x1fbaf8a0_0 .net *"_ivl_3", 0 0, L_0x1fbb0fd0;  1 drivers
v0x1fbaf960_0 .net *"_ivl_5", 0 0, L_0x1fbb1070;  1 drivers
v0x1fbafa00_0 .net *"_ivl_7", 0 0, L_0x1fbb1160;  1 drivers
v0x1fbafac0_0 .net "xnor_a", 0 0, o0x7f7d1139efa8;  0 drivers
v0x1fbafbd0_0 .net "xnor_b", 0 0, o0x7f7d1139efd8;  0 drivers
v0x1fbafc90_0 .net "xnor_out", 0 0, L_0x1fbb1270;  1 drivers
L_0x1fbb1070 .reduce/nor L_0x1fbb0fd0;
L_0x1fbb1270 .reduce/nor L_0x1fbb1160;
    .scope S_0x1fb7beb0;
T_0 ;
    %wait E_0x1fb42530;
    %load/vec4 v0x1fbaaba0_0;
    %flag_set/vec4 8;
    %jmp/0xz  T_0.0, 8;
    %pushi/vec4 0, 0, 1;
    %assign/vec4 v0x1fbaaae0_0, 0;
    %jmp T_0.1;
T_0.0 ;
    %load/vec4 v0x1fbaaa00_0;
    %assign/vec4 v0x1fbaaae0_0, 0;
T_0.1 ;
    %jmp T_0;
    .thread T_0;
    .scope S_0x1fb81b80;
T_1 ;
    %vpi_call/w 5 27 "$dumpfile", "dump.vcd" {0 0 0};
    %vpi_call/w 5 28 "$dumpvars", 32'sb00000000000000000000000000000001 {0 0 0};
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf220_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf220_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 0, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf2e0_0, 0, 1;
    %pushi/vec4 1, 0, 1;
    %store/vec4 v0x1fbaf3a0_0, 0, 1;
    %delay 2, 0;
    %vpi_call/w 5 66 "$finish" {0 0 0};
    %end;
    .thread T_1;
# The file index is used to find the file name in the following table.
:file_names 8;
    "N/A";
    "<interactive>";
    "-";
    "8_gates.sv";
    "clk.sv";
    "testbench.sv";
    "full_adder.sv";
    "half-full-adder.sv";
